{"version":3,"sources":["util/EmojiMapper.ts","components/Header.tsx","components/Emoji.tsx","components/Container.tsx","components/Footer.tsx","serviceWorker.ts","index.tsx","components/App.tsx"],"names":["EmojiMapper","sort","Math","random","Header","props","className","href","message","score","topScore","Emoji","src","image","alt","onClick","emojiClicked","Container","join","children","Footer","title","Boolean","window","location","hostname","match","ReactDOM","render","useState","updateScore","updateTopScore","getImages","emojis","shuffle","setMessage","Set","clickedSet","updateClicked","clicked","has","add","newScore","map","url","key","createEmoji","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"iLA4CeA,E,yGAJP,MAtCe,CACX,kBACA,oBACA,kBACA,oBACA,oBACA,qBACA,uBACA,mBACA,qBACA,wBACA,sBACA,kBACA,oBACA,oBACA,oBACA,oBACA,gBACA,oBACA,oBACA,gBACA,iBACA,kBACA,kBACA,gBACA,mBACA,kBACA,kBACA,oBACA,sBACA,wBACA,uBACA,uBACA,yBACA,oBACA,kBAGUC,MAAK,kBAAMC,KAAKC,SAAW,U,KChCpCC,EAA2B,SAACC,GACrC,OACI,4BAAQC,UAAU,2BACd,yBAAKA,UAAU,yBACX,yBAAKA,UAAU,cACX,yBAAKA,UAAU,OACX,yBAAKA,UAAU,mBACX,uBAAGA,UAAU,aAAaC,KAAK,KAC3B,mDAGR,yBAAKD,UAAU,mBACX,4BAAKD,EAAMG,UAEf,yBAAKF,UAAU,mBACX,sCACYD,EAAMI,MADlB,gBACsC,IACjCJ,EAAMK,gBCjB1BC,EAAyB,SAACN,GAKnC,OACI,yBACIC,UAAU,YACVM,IAAKP,EAAMQ,MACXC,IAAKT,EAAMS,IACXC,QATa,WACjBV,EAAMW,aAAaX,EAAMQ,WCRpBI,EAAgB,SAACZ,GAS1B,OAAO,6BAASC,UAPmB,CAC/B,MACA,SACA,YACA,2BAGwCY,KAAK,MAAOb,EAAMc,WCTrDC,EAAa,WACtB,OACI,4BAAQd,UAAU,sBACd,uBAAGA,UAAU,YAAb,8BACA,uBAAGA,UAAU,YAAb,gBAEI,uBACIC,KAAK,8CACLc,MAAM,cAEL,gBAEJ,SACD,uBAAGd,KAAK,4BAA4Bc,MAAM,YAA1C,uBCHIC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCbNC,IAASC,OAAO,mBCEa,WAAmB,MAEfC,mBAAiB,GAFF,mBAErCpB,EAFqC,KAE9BqB,EAF8B,OAGTD,mBAAiB,GAHR,mBAGrCnB,EAHqC,KAG3BqB,EAH2B,OAIlBF,mBAAmB7B,EAAYgC,aAJb,mBAIrCC,EAJqC,KAI7BC,EAJ6B,OAKdL,mBAAiB,6BALH,mBAKrCrB,EALqC,KAK5B2B,EAL4B,OAMRN,mBAAsB,IAAIO,KANlB,mBAMrCC,EANqC,KAMzBC,EANyB,KAStCC,EAAU,SAAC1B,GAKb,GAHAqB,EAAQlC,EAAYgC,aAGhBK,EAAWG,IAAI3B,GAIf,OAHAsB,EAAW,qCACXL,EAAY,QACZQ,EAAc,IAAIF,KAKtBE,GAAc,SAAAD,GAAU,OAAIA,EAAWI,IAAI5B,MAC3CsB,EAAW,yBACX,IAAMO,EAAmBjC,EAAQ,EACjCqB,EAAYY,GACRA,EAAWhC,GACXqB,EAAeW,IAgBvB,OACI,oCACI,kBAAC,EAAD,CAAQjC,MAAOA,EAAOC,SAAUA,EAAUF,QAASA,IACnD,kBAAC,EAAD,KAAYyB,EAAOU,KAAI,SAAAC,GAAG,OAdd,SAACA,GACjB,OACI,kBAAC,EAAD,CACIC,IAAKD,EACL/B,MAAO+B,EACP9B,IAAK,cACLE,aAAcuB,IAQYO,CAAYF,OAC1C,kBAAC,EAAD,SDjDI,MAASG,SAASC,eAAe,SDoI3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,iB","file":"static/js/main.acbf214c.chunk.js","sourcesContent":["class EmojiMapper {\r\n    static getImages(): string[] {\r\n        const images = [\r\n            'emoji/angry.png',\r\n            'emoji/angry-1.png',\r\n            'emoji/bored.png',\r\n            'emoji/bored-1.png',\r\n            'emoji/bored-2.png',\r\n            'emoji/confused.png',\r\n            'emoji/confused-1.png',\r\n            'emoji/crying.png',\r\n            'emoji/crying-1.png',\r\n            'emoji/embarrassed.png',\r\n            'emoji/emoticons.png',\r\n            'emoji/happy.png',\r\n            'emoji/happy-1.png',\r\n            'emoji/happy-2.png',\r\n            'emoji/happy-3.png',\r\n            'emoji/happy-4.png',\r\n            'emoji/ill.png',\r\n            'emoji/in-love.png',\r\n            'emoji/kissing.png',\r\n            'emoji/mad.png',\r\n            'emoji/nerd.png',\r\n            'emoji/ninja.png',\r\n            'emoji/quiet.png',\r\n            'emoji/sad.png',\r\n            'emoji/secret.png',\r\n            'emoji/smart.png',\r\n            'emoji/smile.png',\r\n            'emoji/smiling.png',\r\n            'emoji/surprised.png',\r\n            'emoji/surprised-1.png',\r\n            'emoji/suspicious.png',\r\n            'emoji/tongue-out.png',\r\n            'emoji/tongue-out-1.png',\r\n            'emoji/unhappy.png',\r\n            'emoji/wink.png'\r\n        ];\r\n\r\n        return images.sort(() => Math.random() - 0.5);\r\n    }\r\n}\r\n\r\nexport default EmojiMapper;\r\n","import React, { FC } from 'react';\r\n\r\ninterface IHeaderProps {\r\n    score: Number;\r\n    topScore: Number;\r\n    message: string;\r\n}\r\n\r\nexport const Header: FC<IHeaderProps> = (props): JSX.Element => {\r\n    return (\r\n        <header className='text-light bg-dark py-4'>\r\n            <nav className='navbar sticky-top p-0'>\r\n                <div className='grid w-100'>\r\n                    <div className='row'>\r\n                        <div className='col text-center'>\r\n                            <a className='text-light' href='/'>\r\n                                <h3>Emoji Clicky Game</h3>\r\n                            </a>\r\n                        </div>\r\n                        <div className='col text-center'>\r\n                            <h3>{props.message}</h3>\r\n                        </div>\r\n                        <div className='col text-center'>\r\n                            <h3>\r\n                                Score: {props.score} | Top Score:{' '}\r\n                                {props.topScore}\r\n                            </h3>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n            </nav>\r\n        </header>\r\n    );\r\n};\r\n","import React, { FC } from 'react';\r\n\r\ninterface IEmojiProps {\r\n    image: string;\r\n    alt: string;\r\n    emojiClicked: (image: string) => void;\r\n}\r\n\r\nexport const Emoji: FC<IEmojiProps> = (props): JSX.Element => {\r\n    const onEmojiClick = () => {\r\n        props.emojiClicked(props.image);\r\n    };\r\n\r\n    return (\r\n        <img\r\n            className='emoji m-3'\r\n            src={props.image}\r\n            alt={props.alt}\r\n            onClick={onEmojiClick}\r\n        />\r\n    );\r\n};\r\n","import React, { FC } from 'react';\r\n\r\nexport const Container: FC = (props): JSX.Element => {\r\n\r\n    const containerClasses: string[] = [\r\n        'p-5',\r\n        'd-flex',\r\n        'flex-wrap',\r\n        'justify-content-between',\r\n    ];\r\n\r\n    return <section className={containerClasses.join(' ')}>{props.children}</section>;\r\n};\r\n\r\n\r\n","import React, { FC } from 'react';\r\n\r\nexport const Footer: FC = (): JSX.Element => {\r\n    return (\r\n        <footer className='text-light bg-dark'>\r\n            <p className='py-1 m-0'>Created By: Brandt K Strom</p>\r\n            <p className='py-1 m-0'>\r\n                Icons made by\r\n                <a\r\n                    href='https://www.flaticon.com/authors/roundicons'\r\n                    title='Roundicons'\r\n                >\r\n                    {' Roundicons '}\r\n                </a>\r\n                {' from '}\r\n                <a href='https://www.flaticon.com/' title='Flaticon'>\r\n                    www.flaticon.com\r\n                </a>\r\n            </p>\r\n        </footer>\r\n    );\r\n};\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { App } from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import React, { useState } from 'react';\nimport EmojiMapper from '../util/EmojiMapper';\nimport { Header } from './Header';\nimport { Emoji } from './Emoji';\nimport { Container } from './Container';\nimport { Footer } from './Footer';\n\nexport const App: React.FC = (): JSX.Element => {\n    // State hooks\n    const [score, updateScore] = useState<number>(0);\n    const [topScore, updateTopScore] = useState<number>(0);\n    const [emojis, shuffle] = useState<string[]>(EmojiMapper.getImages());\n    const [message, setMessage] = useState<string>('Click any emoji to begin!');\n    const [clickedSet, updateClicked] = useState<Set<string>>(new Set());\n\n    // Click handler for when an emoji is clicked\n    const clicked = (image: string): void => {\n        // Shuffle emojis\n        shuffle(EmojiMapper.getImages());\n\n        // Check to see if emoji already clicked... reset if true\n        if (clickedSet.has(image)) {\n            setMessage('Emoji already guessed. Try again!');\n            updateScore(0);\n            updateClicked(new Set<string>());\n            return;\n        }\n\n        // If first click, update scores and continue\n        updateClicked(clickedSet => clickedSet.add(image));\n        setMessage('Good job! Keep going!');\n        const newScore: number = score + 1;\n        updateScore(newScore);\n        if (newScore > topScore) {\n            updateTopScore(newScore);\n        }\n    };\n\n    // Creates Emoji component from provided image URL\n    const createEmoji = (url: string): JSX.Element => {\n        return (\n            <Emoji\n                key={url}\n                image={url}\n                alt={'emoji image'}\n                emojiClicked={clicked}\n            />\n        );\n    };\n\n    return (\n        <>\n            <Header score={score} topScore={topScore} message={message} />\n            <Container>{emojis.map(url => createEmoji(url))}</Container>\n            <Footer />\n        </>\n    );\n};\n"],"sourceRoot":""}